# Chapter 2-1. 클린코드와 리팩토링

## 기본과제: 더티코드 개선

이번 과제는 더티코드를 클린코드의 형태로 개선을 하는 과제입니다. 주어진 테스트를 통과하면서 원래 기능과 동일한 동작을 하는 코드를 만들어주세요. basic과제는 제공되는 더티코드를 클린코드와 리팩토링 원칙에 입각해서 더 나은 코드로 만들어보세요. 주어진 테스트를 참고삼아 좋은 이름, 좋은 모양, 좋은 구조를 가지는 코드로 만들어 보세요.

[필수조건]

- Prettier와 ESLint를 설치해서 적용할 것
- 테스트 코드 모두 통과할 것
- = 기존 기능과 동일하게 동작할 것
- = 어플리케이션 요구사항을 모두 만족할 것
  - 상품
    - 상품1 - 10,000원
    - 상품2 - 20,000원
    - 상품3 - 30,000원
  - 상품 관리
    - 상품을 장바구니에 추가할 수 있어야 한다.
    - 장바구니에서 상품을 제거할 수 있어야 한다.
    - 각 상품의 수량을 변경할 수 있어야 한다.
    - 재고가 부족한 상품은 장바구니에 담을 수 없습니다.
  - 가격 계산
    - 장바구니 내 모든 상품의 총액을 계산해야 한다.
    - 개별 상품의 가격과 수량에 따른 소계를 표시해야 한다.
    - 상품1 > 10개 이상 구매 시 10% 할인
    - 상품2 > 10개 이상 구매 시 15% 할인
    - 상품3 > 10개 이상 구매 시 20% 할인
    - 상품 종류와 상관 없이, 30개 이상 구매할 경우 25% 할인
    - 화요일에는 특별할인 10%
    - 임의의 시간마다 깜짝세일 20%, 추천세일 5%
  - 기본 기능
    - 장바구니에 상품 추가 기능
    - 장바구니에서 상품 제거 기능
    - 상품 수량 변경 기능
    - 장바구니 내역 조회 기능
    - 총액 계산 기능

## 심화과제: 유지보수 하기 좋은 코드만들기

심화과제는 **기본과제에서 작성한 코드를 기술고도화를 하는 것입니다.** 바닐라 자바스크립트로 되어 있는 코드를 유지보수하기에 유리한 기술스택(React + Typescript)으로 고도화 리팩토링을 진행해주세요.
우리의 목표는 앞으로 유지보수를 더 잘할 수 있도록 하기 위함입니다. 최소 React와 Typescript를 이용한 코드로 개선해주세요. 그 밖의 기술선택과 폴더/파일 구조, 테스트 코드등은 자유입니다.

## 요청사항

과제를 진행할 떄 AI를 쓰는 것은 자유입니다. 오히려 AI를 활용하는 연습을 해야하는게 시대의 흐름이겠지요.
다만 AI를 쓰더라도 최대한 조금씩 조금씩 이전 코드와 지금 코드를 그대로 유지하면서 리팩토링하는 감각을 기르기 위함이나,
AI에게 최대한 조금씩 그러나 구체적으로 요청하며 한번에 많은 코드를 바꾸지 않도록 하는 연습을 해보세요.

## 회고

### 1. 과제 개요 및 목적

이번 과제는 기존 Vanilla JS 코드의 구조적 한계를 인식하고, 이를 리팩토링 및 리액트 기반으로 마이그레이션하는 것이 목적이었다. 코드는 총 3단계로 나뉘어 있었다.

- original: 구조화되지 않은 js 코드
- basic: 구조화된 vanilla js 코드
- advanced: React + TypeScript 기반 리팩토링

### 2. Original 코드 분석 및 문제 인식

처음 주어진 코드는 상태와 UI가 뒤섞여 있고, 전역 변수로 DOM과 상태를 관리하고 있었다.
`main()` 함수에서 모든 요소가 생성되고, 그 안에서 상태 변경과 렌더링이 모두 일어나는 구조였다.

- 전역 변수로 DOM과 상태가 혼재
- 하나의 함수가 UI 렌더링, 비즈니스 로직, 상태 변경까지 모두 담당
- 특정 UI 동작이 어디에서 발생하는지 추적이 어려움
- 테스트 및 유지보수 어려움

### 3. Basic 단계: Vanilla JS 리팩토링

original 코드의 구조적 문제를 개선하기 위해 Vanilla JS 기반의 리팩토링을 진행했다. 이 단계의 핵심은 역할 분리와 명확한 흐름 구조화였다.

> 상태 관리

- 전역으로 흩어져 있던 `let` 상태들을 `Store` 객체로 분리하고 `get / set` 기반의 단방향 데이터 흐름 구성

> DOM 관리

- 각 UI 요소를 역할 단위로 모듈화 (`CartDOM`, `ProductDOM` 등), `init()`을 통한 선언과 `get()`을 통한 접근 구조 도입

> 핸들러, 렌더, 계산 로직 분리

- DOM 조작, 데이터 계산, 이벤트 핸들러를 각각의 함수 또는 파일로 분리하여 책임을 분명히 함
- `updateStockStatus`, `renderBonusPoints`, `calculateCartAmounts` 등

> 네이밍 컨벤션 정립

- `create` / `render` / `update` / `init` 네이밍 기준 수립 → 함수 역할을 명확하게 전달

#### 🧠 주요 고민들

- DOM과 상태 간의 결합도를 낮추고, 전역 변수 없이 재사용 가능한 구조를 설계하고자 했음
- 순수 함수를 지향하면서도 DOM 접근, 상태 전달 등 현실적인 트레이드오프에 대한 절충이 필요했음
- 클로저 기반의 DOM 관리 방식이 재사용에 한계를 보여, 기능 단위의 DOM 모듈 분리가 필요하다고 판단
- `store`라는 명칭과 역할을 명확히 구분하기 위해 상태와 DOM의 책임을 분리했음
- 네이밍 컨벤션(`create`, `render`, `update`, `init` 등)을 일관성 있게 정립하기 위한 기준 고민
- 리액트 마이그레이션을 고려해, DOM 중심 구조를 어디까지 정리하고 재사용 가능한 로직으로 만들지에 대한 고민
- 리액트의 상태 불변성과 흐름을 염두에 두고 설계하려고 노력함. 특히 setState 시의 참조 일관성과 불변성 유지의 어려움을 vanilla 구조 안에서 구현해보려 했음

### 4. Advanced 단계: React + TypeScript 리팩토링

Basic 구조를 기반으로, React + TypeScript 환경으로 마이그레이션을 진행했다.
이 단계의 핵심은 DOM 기반의 선언적 코드를 명령형 컴포넌트 기반 구조로 전환하고, 상태 관리를 React의 철학에 맞게 재설계하는 것이었다.

> 순수 함수 재사용

- 기존 JS 코드 중 DOM을 직접 다루지 않는 계산/조건 로직들을 ts 파일로 래핑하여 React에서도 그대로 활용

> 렌더링 구조 전환

- DOM 조작 코드는 JSX 기반의 컴포넌트로 전환, 스타일 클래스는 유지하며 컴포넌트 단위 분할

> 상태 구조화

- products, cartItems, selectedProduct 상태를 각각 useState로 분리
- 계산 로직은 useMemo 기반으로 useCartCalculations 훅에 분리

> 액션 분리

- add, update, remove 등의 액션은 useCartActions 훅으로 분리
- 로직이 길어지지 않도록 액션 단위 함수들로 세분화

> 커스텀 훅 통합

- useCartActions, useProductState, useSelectedProduct, useCartCalculations 훅을 useShopping 훅에서 통합

#### 🧠 주요 고민들

- 커스텀 훅만으로 상태를 관리하려 했지만, 훅이 재실행될 때마다 내부 상태가 초기화되거나 공유되지 않아 의도한 데이터 흐름이 유지되지 않음 → 결국 `context`를 활용해 상태를 안정적으로 유지하는 구조로 변경

- 훅은 재사용성과 관심사 분리에 유리했지만, 상태 간 의존성이 생기면서 결국 하나의 통합 훅(`useShopping`)으로 모아 관리하는 방식이 더 효과적이었음

- `cartItems`, `products`, `selectedProduct`가 서로 영향을 주는 구조였기 때문에 각각 따로 관리하면 상태 동기화가 어려워지고, 중복된 상태 갱신 로직이 발생했음 → 하나의 흐름으로 묶어서 불필요한 상태 분산과 남용을 줄임

- 기존 코드는 옵저버 패턴 없이 DOM을 직접 수정하는 방식이었기 때문에, 이 구조를 React의 상태 기반 흐름으로 전환하는 과정에서 전체적인 설계 전환이 필요했음

- 관심사 분리, 단방향 데이터 흐름, 불변성 유지가 복잡한 구조일수록 리팩토링의 핵심 기준이 된다는 것을 체감함

### 5. Biome 도입 및 Formatter 관리

이번 과제에서는 포맷터 및 린터 설정도 함께 구성했으며, 특히 프로젝트 내에서 basic과 advanced 디렉토리에 서로 다른 포맷팅 도구를 적용하는 구조로 관리했다.

> 도입 배경

- advanced 디렉토리는 팀 컨벤션에 따라 `Biome`을 사용하기로 결정해, 기존 `Prettier + ESLint` 구조와 병행해 적용이 필요했다.
- 따라서 basic은 기존처럼 `Prettier + ESLint`를 유지하면서, advanced 디렉토리만 `Biome`으로 전환해 관리하는 구조로 구성했다.

> 적용 방식

- `biome.json` 설정 파일을 루트에 생성하되, `biomeignore`를 통해 범위 조정
- `src/advanced`만 `Biome` 포맷팅 대상이 되도록 설정
- `.prettierignore`, `.eslintignore`와 함께 각 포맷터별 적용 범위를 명확히 분리

하나의 프로젝트에서 포맷터와 린터를 디렉토리 단위로 나눠 적용한 경험 자체가 흥미로웠고, 도구가 달라도 설정만 잘하면 공존할 수 있다는 점을 체감할 수 있었다.

### 6. 마이그레이션 & 리팩토링을 하며 느낀 점

이번 과제는 단순히 기능을 리팩토링하거나 React로 마이그레이션하는 작업이 아니었다. 기존 구조의 문제를 "어디까지 분리할 수 있을까", 그리고 "어디서부터가 타협해야 하는 지점일까"를 끝없이 고민하는 시간이었다.

Vanilla JS 리팩토링 단계에선 특히 "순수함수를 지향하고 싶지만 결국 DOM을 직접 건드려야 할 때 어디까지 타협할 것인가"가 가장 큰 고민이었다. 가능한 모든 상태는 `store`로 옮기고, UI 업데이트는 `render` 함수로 분리하려 했지만, 결국 대부분의 이벤트 핸들러에서는 DOM 요소에 직접 접근해서 값을 수정해야 했다. "이걸 `props`로 내려줄까? 아니면 `store`에 다 넣어버릴까?" 같은 고민을 계속하면서, 가독성과 책임 분리 사이에서 수십 번 왔다 갔다 했다.

그런 고민은 React로 넘어가서도 이어졌다. 처음에는 모든 상태와 액션을 `context`에 한데 모아 관리했다. 구조적으로 문제는 없었지만 이 방식이 리액트스러운 설계인가에 대한 의문이 생겼고, 관심사 분리를 위해 `useProductState`, `useCartActions` 같은 `custom hook`으로 각각의 상태와 로직을 나눴다. 하지만 이렇게 나눈 `hook`들을 `useShopping`이라는 상위 훅에서 다시 조합하는 과정에서 문제가 생겼다. `hook`이 매 렌더링마다 새롭게 실행되다 보니, 각 `hook` 내부에서 사용하는 상태들이 매번 초기화되거나 서로 엇갈리는 상황이 발생한 것이다. 결국 다시 `context` 내부로 각 `hook`을 이동시키고, `context`를 통해 안정적으로 상태를 공유하는 방식으로 구조를 정리했다. 이 경험을 통해 단순히 상태를 나누는 것보다, 상태가 변하지 않고 일관되게 유지되는 구조를 만드는 것이 더 중요하다는 걸 깨달았다.

게다가 기존 JS 로직을 React로 옮기는 게 그렇게 쉽진 않았다. DOM을 직접 조작하던 방식은 컴포넌트 기반의 선언형 구조와는 전혀 맞지 않았기 때문에, 단순한 코드 이전이 아니라 로직과 흐름 자체를 처음부터 다시 설계하는 작업이 필요했다. 기존 로직을 그대로 가져올 수 있을지 고민하면서, 재사용 가능한 로직은 최대한 함수로 분리하고, 나머지는 리액트에 맞는 방식으로 하나하나 다시 구현해나가야 했다.

리팩토링은 단순히 코드를 예쁘게 정리하는 작업이 아니었다. 책임을 어디서부터 나눌지, 상태를 어떻게 흐르게 할지, 그리고 DOM과 데이터의 연결 고리를 어떻게 끊어낼지를 끊임없이 고민하는 과정이었다. 결국 설계를 먼저 고민하다 보니, 코드가 자연스럽게 그 흐름을 따라 정리되어 갔다.

### 7. 과제 중 질문 사항

> 순수 함수와 DOM 조작 간의 책임 분리

basic 과제를 진행할 때 가장 많이 고민한 부분 중 하나는 가능한 모든 로직을 순수 함수로 분리하고자 했던 점입니다. 하지만 이벤트 핸들러 내부에서는 결국 DOM을 직접 조작할 수밖에 없는 구조가 많았습니다. props로 모든 DOM 요소를 전달하면 코드가 과도하게 복잡해지고, 전역에 노출하면 구조의 안정성이 떨어졌습니다. 실무에서는 이러한 상황에서 어느 정도까지 순수성을 지키고, 어떤 부분은 타협하는 것이 좋은지 궁금합니다.

> 리팩토링에서 재사용 가능한 로직의 기준이 궁금합니다

기존 로직 중 일부는 React로 마이그레이션할 때도 재사용할 수 있을 것이라 생각해 순수 함수로 분리해두었지만, 대부분이 DOM에 묶여 있어 꽤 많은 로직을 추가로 작성하게 되었습니다. 그렇다고 모든 로직을 함수로 추출하면 오히려 복잡도가 높아지는 문제가 있었습니다. 멘토님께서는 어떤 기준으로 "이 로직은 재사용 가능하다"는 판단을 내리는지 궁금합니다.

> 액션 함수에서 DOM 조작이 필요한 경우, 분리 가능한 구조가 있는지 궁금합니다

Vanilla JS 환경에서는 액션 함수 내부에서 바로 DOM을 조작하는 것이 자연스러운 흐름이었지만, 이를 update/render 함수로 나누는 구조를 시도하면서 오히려 흐름이 더 복잡해지는 경험을 했습니다. 이런 상황에서 액션과 DOM 업데이트를 어떻게 분리하면 좋을지, 혹은 굳이 나누지 않고 함께 관리하는 경우가 더 많은지도 궁금합니다.
